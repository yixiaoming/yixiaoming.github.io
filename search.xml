<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[LiveData源码解析]]></title>
      <url>/2019/03/24/LiveData%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
      <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>LiveData是Android Jetpack Conponent中一个重要的组件，它能将数据与Android生命周期组件(Activity/Fragment/Service等，注：下文讲解实例中直接将生命周期组件替换成Activity，其他组件大同小异)进行有机的绑定，当数据变化时只通知active的组件，当组件销毁时自动解除关系避免内存泄漏，避免了我们在生命周期中写很长的代码来拉去数据更新UI，将数据变化与UI Control分离开，非常好用。下文我们将分析LiveData源码是怎么做到的，文中例子代码直接来自于Android Developer官方文档示例代码。</p>
<p>地址：<a href="https://developer.android.com/topic/libraries/architecture/livedata" target="_blank" rel="noopener">https://developer.android.com/topic/libraries/architecture/livedata</a></p>
<p>来一张简图：</p>
<p><img src="/2019/03/24/LiveData源码解析/./image-20190324221458032.png" alt=""></p>
<a id="more"></a>
<h2 id="LiveData代码示例"><a href="#LiveData代码示例" class="headerlink" title="LiveData代码示例"></a>LiveData代码示例</h2><ol>
<li>创建ViewModel类，里面存放LiveData对象</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NameViewModel</span> <span class="keyword">extends</span> <span class="title">ViewModel</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create a LiveData with a String</span></span><br><span class="line"><span class="keyword">private</span> MutableLiveData&lt;String&gt; currentName;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MutableLiveData&lt;String&gt; <span class="title">getCurrentName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (currentName == <span class="keyword">null</span>) &#123;</span><br><span class="line">            currentName = <span class="keyword">new</span> MutableLiveData&lt;String&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> currentName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Rest of the ViewModel...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>通过Observer将LiveData与生命周期组件绑定，在OnChanged回调中修改UI</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NameActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> NameViewModel model;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Other code to setup the activity...</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Get the ViewModel.</span></span><br><span class="line">        model = ViewModelProviders.of(<span class="keyword">this</span>).get(NameViewModel.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Create the observer which updates the UI.</span></span><br><span class="line">        <span class="keyword">final</span> Observer&lt;String&gt; nameObserver = <span class="keyword">new</span> Observer&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onChanged</span><span class="params">(@Nullable <span class="keyword">final</span> String newName)</span> </span>&#123;</span><br><span class="line">                <span class="comment">// Update the UI, in this case, a TextView.</span></span><br><span class="line">                nameTextView.setText(newName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Observe the LiveData, passing in this activity as the LifecycleOwner and the observer.</span></span><br><span class="line">        model.getCurrentName().observe(<span class="keyword">this</span>, nameObserver);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>使用LiveData通知数据变化，LiveData更新数据有两个方法setValue和postValue后一个在主线程执行，前者在当前线程执行。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">button.setOnClickListener(<span class="keyword">new</span> OnClickListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">        String anotherName = <span class="string">"John Doe"</span>;</span><br><span class="line">        model.getCurrentName().setValue(anotherName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h2><p>先看一下LiveData相关的几个类：</p>
<h3 id="MutableLiveData类"><a href="#MutableLiveData类" class="headerlink" title="MutableLiveData类"></a>MutableLiveData类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MutableLiveData</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">LiveData</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postValue</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.postValue(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.setValue(value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>继承于LiveData主要提供一层泛型，让LiveData支持任何数据类型，主要功能还是在LiveData中实现。</p>
<h3 id="Observer接口"><a href="#Observer接口" class="headerlink" title="Observer接口"></a>Observer接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Observer</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Called when the data is changed.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t  The new data</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onChanged</span><span class="params">(@Nullable T t)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主要提供onChanged(T t)接口给LiveData通知数据变化，没什么好看的。主要看LiveData的observe()方法，怎么讲Observer对象绑定在一起。</p>
<h3 id="LiveData类"><a href="#LiveData类" class="headerlink" title="LiveData类"></a>LiveData类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@MainThread</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">observe</span><span class="params">(@NonNull LifecycleOwner owner, @NonNull Observer&lt;T&gt; observer)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果生命周期组件的state已经destory，则不绑定</span></span><br><span class="line">    <span class="keyword">if</span> (owner.getLifecycle().getCurrentState() == DESTROYED) &#123;</span><br><span class="line">        <span class="comment">// ignore</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建lifecycle于observer绑定对象，wrapper模式</span></span><br><span class="line">    LifecycleBoundObserver wrapper = <span class="keyword">new</span> LifecycleBoundObserver(owner, observer);</span><br><span class="line">    <span class="comment">// 判断observer是否已经添加到其他生命周期组件中，一个observer只能绑定一个</span></span><br><span class="line">    ObserverWrapper existing = mObservers.putIfAbsent(observer, wrapper);</span><br><span class="line">    <span class="keyword">if</span> (existing != <span class="keyword">null</span> &amp;&amp; !existing.isAttachedTo(owner)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Cannot add the same observer"</span></span><br><span class="line">                + <span class="string">" with different lifecycles"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (existing != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 生命周期owner添加wrapper观察者</span></span><br><span class="line">    owner.getLifecycle().addObserver(wrapper);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果你不知道LifecycleOwner是啥玩意儿，可能看注释有点懵逼，你可以简单理解为Activity，通过LifecycleOwner可通过getLifecycle()获取到当前抓紧的Lifecyle对象，这个对象可以感知Activity等组件的生命周期变化，所以你要获取activity的生命周期，不一定要拿到activity实例，直接获取跟activity绑定的Lifecycle对象即可。扯远了，继续看LifecycleBoundObserver对象</p>
<p>创建LifecycleBoundObserver之后，最后会调用：</p>
<p><code>owner.getLifecycle().addObserver(wrapper)</code></p>
<p>这样生命周期组件的生命周期变化就能通知到Observer对象，至于为什么这里要加一层wrapper，当然是由一些通用的逻辑需要在wrapper中处理，而不是普通的Observer对象。</p>
<h3 id="LifecycleBoundObserver类"><a href="#LifecycleBoundObserver类" class="headerlink" title="LifecycleBoundObserver类"></a>LifecycleBoundObserver类</h3><p>它是LiveData的内部类，并且继承于<strong>ObserverWrapper</strong>，实现<strong>GenericLifecycleObserver接口</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LifecycleBoundObserver</span> <span class="keyword">extends</span> <span class="title">ObserverWrapper</span> <span class="keyword">implements</span> <span class="title">GenericLifecycleObserver</span> </span>&#123;</span><br><span class="line">    <span class="meta">@NonNull</span> <span class="keyword">final</span> LifecycleOwner mOwner;</span><br><span class="line"></span><br><span class="line">    LifecycleBoundObserver(<span class="meta">@NonNull</span> LifecycleOwner owner, Observer&lt;T&gt; observer) &#123;</span><br><span class="line">        <span class="keyword">super</span>(observer);</span><br><span class="line">        mOwner = owner;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">shouldBeActive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mOwner.getLifecycle().getCurrentState().isAtLeast(STARTED);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStateChanged</span><span class="params">(LifecycleOwner source, Lifecycle.Event event)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mOwner.getLifecycle().getCurrentState() == DESTROYED) &#123;</span><br><span class="line">            removeObserver(mObserver);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        activeStateChanged(shouldBeActive());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isAttachedTo</span><span class="params">(LifecycleOwner owner)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mOwner == owner;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">detachObserver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mOwner.getLifecycle().removeObserver(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ObserverWrapper类"><a href="#ObserverWrapper类" class="headerlink" title="ObserverWrapper类"></a>ObserverWrapper类</h3><p>也是LiveData的内部类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ObserverWrapper</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Observer&lt;T&gt; mObserver;</span><br><span class="line">    <span class="keyword">boolean</span> mActive;</span><br><span class="line">    <span class="keyword">int</span> mLastVersion = START_VERSION;</span><br><span class="line"></span><br><span class="line">    ObserverWrapper(Observer&lt;T&gt; observer) &#123;</span><br><span class="line">        mObserver = observer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">shouldBeActive</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isAttachedTo</span><span class="params">(LifecycleOwner owner)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">detachObserver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">activeStateChanged</span><span class="params">(<span class="keyword">boolean</span> newActive)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (newActive == mActive) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// immediately set active state, so we'd never dispatch anything to inactive</span></span><br><span class="line">        <span class="comment">// owner</span></span><br><span class="line">        mActive = newActive;</span><br><span class="line">        <span class="keyword">boolean</span> wasInactive = LiveData.<span class="keyword">this</span>.mActiveCount == <span class="number">0</span>;</span><br><span class="line">        LiveData.<span class="keyword">this</span>.mActiveCount += mActive ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (wasInactive &amp;&amp; mActive) &#123;</span><br><span class="line">            onActive();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (LiveData.<span class="keyword">this</span>.mActiveCount == <span class="number">0</span> &amp;&amp; !mActive) &#123;</span><br><span class="line">            onInactive();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (mActive) &#123;</span><br><span class="line">            dispatchingValue(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="GenericLifecycleObserver接口"><a href="#GenericLifecycleObserver接口" class="headerlink" title="GenericLifecycleObserver接口"></a>GenericLifecycleObserver接口</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public interface GenericLifecycleObserver extends LifecycleObserver &#123;</span><br><span class="line">    /**</span><br><span class="line">     * Called when a state transition event happens.</span><br><span class="line">     *</span><br><span class="line">     * @param source The source of the event</span><br><span class="line">     * @param event The event</span><br><span class="line">     */</span><br><span class="line">    void onStateChanged(LifecycleOwner source, Lifecycle.Event event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是Lifecyle的组件，继承自LifecycleObserver，生命周期组件的所有生命周期变化都会通知onStateChanged()，LifecycleBoundObserver重写这个接口即可获取到Activity等组件的生命周期，并处理自己的逻辑。比如：</p>
<p>LifecycleBoundObserver类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStateChanged</span><span class="params">(LifecycleOwner source, Lifecycle.Event event)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">if</span> (mOwner.getLifecycle().getCurrentState() == DESTROYED) &#123;</span><br><span class="line">              <span class="comment">// 如果组件destory了，删除observer</span></span><br><span class="line">              removeObserver(mObserver);</span><br><span class="line">              <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          activeStateChanged(shouldBeActive());</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
<p>ObserverWrapper类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">activeStateChanged</span><span class="params">(<span class="keyword">boolean</span> newActive)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (newActive == mActive) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// immediately set active state, so we'd never dispatch anything to inactive</span></span><br><span class="line">    <span class="comment">// owner</span></span><br><span class="line">    mActive = newActive;</span><br><span class="line">    <span class="keyword">boolean</span> wasInactive = LiveData.<span class="keyword">this</span>.mActiveCount == <span class="number">0</span>;</span><br><span class="line">    LiveData.<span class="keyword">this</span>.mActiveCount += mActive ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">// active count从0变为1，通知active</span></span><br><span class="line">    <span class="keyword">if</span> (wasInactive &amp;&amp; mActive) &#123;</span><br><span class="line">        <span class="comment">// 通知active</span></span><br><span class="line">        onActive();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 所有active的observer数从1变为0，通知inactive</span></span><br><span class="line">    <span class="keyword">if</span> (LiveData.<span class="keyword">this</span>.mActiveCount == <span class="number">0</span> &amp;&amp; !mActive) &#123;</span><br><span class="line">        <span class="comment">// 通知inactive</span></span><br><span class="line">        onInactive();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mActive) &#123;</span><br><span class="line">        <span class="comment">// active的时候dispatch数据，这样当Activity在后台切前台的时候能立即获取到在后台时数据发生的变化</span></span><br><span class="line">        dispatchingValue(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>shouldBeActive()时一个抽象方法，有两个实现：</p>
<p>LifecycleBoundObserver：从Lifecycle组件获取，至少需要<strong>STARTED</strong>以上才active</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">shouldBeActive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mOwner.getLifecycle().getCurrentState().isAtLeast(STARTED);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>AlwaysactiveObserver: 总是active</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">shouldBeActive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="通知数据变化"><a href="#通知数据变化" class="headerlink" title="通知数据变化"></a>通知数据变化</h3><p>我们知道 setValue和postValue两个方法LiveData用来通知数据变化，postValue只不过切换到主线程调用setValue而已。来看看setValue():</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@MainThread</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    assertMainThread(<span class="string">"setValue"</span>);</span><br><span class="line">    <span class="comment">// 数据版本升级</span></span><br><span class="line">    mVersion++;</span><br><span class="line">    <span class="comment">// 保存数据，用一个成员变量，因为LiveData只管理一个抽象的数据</span></span><br><span class="line">    mData = value;</span><br><span class="line">    <span class="comment">// 通知数据变化</span></span><br><span class="line">    dispatchingValue(<span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dispatchingValue</span><span class="params">(@Nullable ObserverWrapper initiator)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果正在dispatch,设置变量dispatch无效为true，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (mDispatchingValue) &#123;</span><br><span class="line">        mDispatchInvalidated = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 开始dispatch</span></span><br><span class="line">    mDispatchingValue = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">// 无效设置成false，表示有效</span></span><br><span class="line">        mDispatchInvalidated = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// 如果传入发起人，只通知传入的initiator</span></span><br><span class="line">        <span class="keyword">if</span> (initiator != <span class="keyword">null</span>) &#123;</span><br><span class="line">            considerNotify(initiator);</span><br><span class="line">            initiator = <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 遍历mObservers中所有的ObserverWrapper，通知所有LiveData的Observer</span></span><br><span class="line">            <span class="keyword">for</span> (Iterator&lt;Map.Entry&lt;Observer&lt;T&gt;, ObserverWrapper&gt;&gt; iterator =</span><br><span class="line">                    mObservers.iteratorWithAdditions(); iterator.hasNext(); )&#123;				  <span class="comment">// 通知变化</span></span><br><span class="line">                considerNotify(iterator.next().getValue());</span><br><span class="line">                <span class="comment">// 如果在dispatch数据的时候再次发生dispatchingValue()，剩下的Observer直接跳过，因为下一轮的数据更新</span></span><br><span class="line">                <span class="keyword">if</span> (mDispatchInvalidated) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">// 如果在dispatch期间没有被新数据打断过，这里就直接过了，如果被打断过，则继续重新notify新的数据</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (mDispatchInvalidated);</span><br><span class="line">    mDispatchingValue = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面dispatch的逻辑有点绕，但是注释写得很清楚，就是在dispatch期间livedata又有新数据来了，打断并全部通知新数据的逻辑，我觉得这里还是写得很妙的，可以学习学习。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">considerNotify</span><span class="params">(ObserverWrapper observer)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果observer状态没有active直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (!observer.mActive) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果observer当前的状态不是active，直接返回（两种实现，前面说过）</span></span><br><span class="line">    <span class="keyword">if</span> (!observer.shouldBeActive()) &#123;</span><br><span class="line">        observer.activeStateChanged(<span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果当前observer的版本号比新数据的还新，直接return</span></span><br><span class="line">    <span class="keyword">if</span> (observer.mLastVersion &gt;= mVersion) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置observer中数据的版本号</span></span><br><span class="line">    observer.mLastVersion = mVersion;</span><br><span class="line">    <span class="comment">// 调用observer的 onChanged回调</span></span><br><span class="line">    observer.mObserver.onChanged((T) mData);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看到这里我们就明白了，生命周期不active的组件是怎么不通知数据变化的。这里每个observer中还有数据版本的概念，保证所有的订阅者都能拿到最新的数据。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>到这里，LiveData的主要逻辑我们就梳理完了，还有一些细节请读者就自己去阅读了。主要把握几个点：</p>
<ol>
<li>LiveData通过LifecycleOwner获取到Lifecycle对象，并通过实现 GenericLifecycleObserver 监听onStateChanged获取到生命周期组件的生命周期变化，进而可以控制对active的组件才通知数据变化。</li>
<li>LiveData对数据版本，以及短时间多次数据变化都有做控制，active的数据Observer都获取到最新的数据。</li>
<li>这里有两个Observer，一个是数据Observer是Activity中注册监听LiveData数据变化的；宁外一个是LiveData为了获取生组件生命周期实现的Observer。不要搞混了。</li>
<li>当生命周期组件从后台切前台等操作，当它active的时候会自动收到最新版本的LiveData数据变化，也是通过onStateChanged监听实现的。</li>
</ol>
<p>然后按照惯例，画一张图：<br><img src="/2019/03/24/LiveData源码解析/./image-20190324221458032.png" alt=""></p>
]]></content>
      
        <categories>
            
            <category> Android源码解析系列 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Android Component </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ViewModel源码解读]]></title>
      <url>/2019/03/24/ViewModel%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/</url>
      <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>本片文章主要解读Android官方推荐组件ViewModel的底层实现原理，ViewModel作为Activity/Fragment等组件的数据容器，可以避免我们在View层自己创建并保存数据，都交给ViewModel管理，在横竖屏切换等场景也能很好适配。让我们再不需要再onSaveInstanceState()来保存临时变量，并且ViewModel可能很好的适应组件的生命周期，在Activity等组件onDestroy()时自动清除数据避免内存泄漏。</p>
<p>先来一张简图：<br><img src="/2019/03/24/ViewModel源码解读/./image-20190324122440712.png" alt="image-20190324122440712"></p>
<a id="more"></a>
<h2 id="源码解读"><a href="#源码解读" class="headerlink" title="源码解读"></a>源码解读</h2><h3 id="使用方法（官网例子）"><a href="#使用方法（官网例子）" class="headerlink" title="使用方法（官网例子）"></a>使用方法（官网例子）</h3><p>第1步：声明ViewModel组件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyViewModel</span> <span class="keyword">extends</span> <span class="title">ViewModel</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> MutableLiveData&lt;List&lt;User&gt;&gt; users;</span><br><span class="line">    <span class="keyword">public</span> LiveData&lt;List&lt;User&gt;&gt; getUsers() &#123;</span><br><span class="line">        <span class="keyword">if</span> (users == <span class="keyword">null</span>) &#123;</span><br><span class="line">            users = <span class="keyword">new</span> MutableLiveData&lt;List&lt;User&gt;&gt;();</span><br><span class="line">            loadUsers();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> users;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">loadUsers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Do an asynchronous operation to fetch users.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第2步：在Activity中获取ViewModel组件，并获取ViewModel中存储的内容</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Create a ViewModel the first time the system calls an activity's onCreate() method.</span></span><br><span class="line">        <span class="comment">// Re-created activities receive the same MyViewModel instance created by the first activity.</span></span><br><span class="line"></span><br><span class="line">        MyViewModel model = ViewModelProviders.of(<span class="keyword">this</span>).get(MyViewModel.class);</span><br><span class="line">        model.getUsers().observe(<span class="keyword">this</span>, users -&gt; &#123;</span><br><span class="line">            <span class="comment">// update UI</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="内容解读"><a href="#内容解读" class="headerlink" title="内容解读"></a>内容解读</h3><p>首先需要注意：</p>
<ol>
<li>ViewModel这家伙不是我们直接new出来的，而是通过ViewModelProviders创建来的，所以其不受Activity等组件生命周期的限制。</li>
<li>如果对LiveData不了解，可以直接忽略。</li>
</ol>
<h4 id="ViewModelProviders-的创建"><a href="#ViewModelProviders-的创建" class="headerlink" title="ViewModelProviders 的创建"></a>ViewModelProviders 的创建</h4><p>那么ViewModel是怎么通过ViewModelProviders创建的呢？首先看<code>ViewModelProviders.of(this)</code>，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ViewModelProvider <span class="title">of</span><span class="params">(@NonNull FragmentActivity activity,</span></span></span><br><span class="line"><span class="function"><span class="params">        @Nullable Factory factory)</span> </span>&#123;</span><br><span class="line">    Application application = checkApplication(activity);</span><br><span class="line">    <span class="keyword">if</span> (factory == <span class="keyword">null</span>) &#123;</span><br><span class="line">        factory = ViewModelProvider.AndroidViewModelFactory.getInstance(application);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ViewModelProvider(ViewModelStores.of(activity), factory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建了一个<strong>ViewModelProvider</strong>对象，有两个参数：</p>
<ol>
<li><strong>ViewModelStores.of(activity)</strong> 最后生成的是一个 <strong>ViewModelStore</strong> 对象</li>
<li><strong>ViewModelProvider.AndroidViewModelFactory.getInstance(application)</strong></li>
</ol>
<p>先看ViewModelStore的创建：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ViewModelStores</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ViewModelStores</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the &#123;<span class="doctag">@link</span> ViewModelStore&#125; of the given activity.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> activity an activity whose &#123;<span class="doctag">@code</span> ViewModelStore&#125; is requested</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> a &#123;<span class="doctag">@code</span> ViewModelStore&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="meta">@MainThread</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ViewModelStore <span class="title">of</span><span class="params">(@NonNull FragmentActivity activity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (activity <span class="keyword">instanceof</span> ViewModelStoreOwner) &#123;</span><br><span class="line">            <span class="keyword">return</span> ((ViewModelStoreOwner) activity).getViewModelStore();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> holderFragmentFor(activity).getViewModelStore();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the &#123;<span class="doctag">@link</span> ViewModelStore&#125; of the given fragment.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> fragment a fragment whose &#123;<span class="doctag">@code</span> ViewModelStore&#125; is requested</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> a &#123;<span class="doctag">@code</span> ViewModelStore&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="meta">@MainThread</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ViewModelStore <span class="title">of</span><span class="params">(@NonNull Fragment fragment)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (fragment <span class="keyword">instanceof</span> ViewModelStoreOwner) &#123;</span><br><span class="line">            <span class="keyword">return</span> ((ViewModelStoreOwner) fragment).getViewModelStore();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> holderFragmentFor(fragment).getViewModelStore();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过of方法，</p>
<ol>
<li>如果传入的Activity或Fragment实现了ViewModelStoreOwner接口，则直接返回getViewModelStore()返回的ViewModelStore</li>
<li>如果传入的组件不是ViewModelStoreOwner，需要获取HolderFragment的ViewModelStore。这是一种兼容方案。这里看一下Activity的方案，同理还有Fragment的，大同小异。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HolderFragment <span class="title">holderFragmentFor</span><span class="params">(FragmentActivity activity)</span> </span>&#123;</span><br><span class="line">    FragmentManager fm = activity.getSupportFragmentManager();</span><br><span class="line">    <span class="comment">// 通过tag从FragmentManager中找Fragment</span></span><br><span class="line">    HolderFragment holder = findHolderFragment(fm);</span><br><span class="line">    <span class="keyword">if</span> (holder != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> holder;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从创建了但是还没有commit的fragment缓存中读取，真正清除实在HolderFragment的onCreate执行后，即承载HolderFragment的容器onCreate()之后</span></span><br><span class="line">    holder = mNotCommittedActivityHolders.get(activity);</span><br><span class="line">    <span class="keyword">if</span> (holder != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> holder;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 注册生命周期回调，在onDestroy的时候清除 mNotCommittedActivityHolders中的对象。</span></span><br><span class="line">    <span class="keyword">if</span> (!mActivityCallbacksIsAdded) &#123;</span><br><span class="line">        mActivityCallbacksIsAdded = <span class="keyword">true</span>;</span><br><span class="line">        activity.getApplication().registerActivityLifecycleCallbacks(mActivityCallbacks);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建HolderFragment并add到FragmentManager中</span></span><br><span class="line">    holder = createHolderFragment(fm);</span><br><span class="line">    mNotCommittedActivityHolders.put(activity, holder);</span><br><span class="line">    <span class="keyword">return</span> holder;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到这里我们获取到了ViewModelOwner，然后通过getViewModelStore()获取到了ViewModelStore对象。ViewModelStoreOwner就是一个提供ViewModelStore的接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ViewModelStoreOwner</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns owned &#123;<span class="doctag">@link</span> ViewModelStore&#125;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> a &#123;<span class="doctag">@code</span> ViewModelStore&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="function">ViewModelStore <span class="title">getViewModelStore</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们来看FragmentActivity对这个接口的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">FragmentActivity extends SupportActivity implements ViewModelStoreOwner,...&#123;</span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> ViewModelStore <span class="title">getViewModelStore</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.getApplication() == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Your activity is not yet attached to the Application instance. You can't request ViewModel before onCreate call."</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.mViewModelStore == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 这里很精髓，会将ViewModel绑定到不因为configuration变化导致Activity销毁被清空的NonConfigurationInstances下</span></span><br><span class="line">        FragmentActivity.NonConfigurationInstances nc = (FragmentActivity.NonConfigurationInstances)<span class="keyword">this</span>.getLastNonConfigurationInstance();</span><br><span class="line">        <span class="keyword">if</span> (nc != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">this</span>.mViewModelStore = nc.viewModelStore;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.mViewModelStore == <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">this</span>.mViewModelStore = <span class="keyword">new</span> ViewModelStore();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.mViewModelStore;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至此终于获取到ViewModelStore对象，是通过ViewModelStoreOwner接口来获取，需要Activity或者Fragment直接实现接口，如果不是先，系统会为我们的组件添加HolderFragment来做兼容。至于ViewModelStore有什么作用，到后面我们再看。现在看第二个参数 <strong>AndroidViewModelFactory</strong>的创建。这个factory类其实是ViewModelProvider的静态内部类，而且是个单例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AndroidViewModelFactory</span> <span class="keyword">extends</span> <span class="title">ViewModelProvider</span>.<span class="title">NewInstanceFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> AndroidViewModelFactory sInstance;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Retrieve a singleton instance of AndroidViewModelFactory.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> application an application to pass in &#123;<span class="doctag">@link</span> AndroidViewModel&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> A valid &#123;<span class="doctag">@link</span> AndroidViewModelFactory&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> AndroidViewModelFactory <span class="title">getInstance</span><span class="params">(@NonNull Application application)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (sInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            sInstance = <span class="keyword">new</span> AndroidViewModelFactory(application);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sInstance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Application mApplication;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a &#123;<span class="doctag">@code</span> AndroidViewModelFactory&#125;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> application an application to pass in &#123;<span class="doctag">@link</span> AndroidViewModel&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AndroidViewModelFactory</span><span class="params">(@NonNull Application application)</span> </span>&#123;</span><br><span class="line">        mApplication = application;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T extends ViewModel&gt; <span class="function">T <span class="title">create</span><span class="params">(@NonNull Class&lt;T&gt; modelClass)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (AndroidViewModel.class.isAssignableFrom(modelClass)) &#123;</span><br><span class="line">            <span class="comment">//noinspection TryWithIdenticalCatches</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> modelClass.getConstructor(Application.class).newInstance(mApplication);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Cannot create an instance of "</span> + modelClass, e);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Cannot create an instance of "</span> + modelClass, e);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InstantiationException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Cannot create an instance of "</span> + modelClass, e);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Cannot create an instance of "</span> + modelClass, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.create(modelClass);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>唯一一个重要方法就是 create方法，通过反射直接创建ViewModel对象。</p>
<h4 id="ViewModelProvider的功能"><a href="#ViewModelProvider的功能" class="headerlink" title="ViewModelProvider的功能"></a>ViewModelProvider的功能</h4><p>刚刚我们分析了通过<code>ViewModelProviders.of(this)</code>创建了一个ViewModelProvider对象，然后我们再看Activity中的代码 <code>model = ViewModelProviders.of(this).get(NameViewModel.class);</code>下一步就是通过 ViewModelProvider的get(Class)方法来获取ViewModel对象：</p>
<p>ViewModelProvider类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@NonNull</span></span><br><span class="line"><span class="meta">@MainThread</span></span><br><span class="line"><span class="keyword">public</span> &lt;T extends ViewModel&gt; <span class="function">T <span class="title">get</span><span class="params">(@NonNull Class&lt;T&gt; modelClass)</span> </span>&#123;</span><br><span class="line">    String canonicalName = modelClass.getCanonicalName();</span><br><span class="line">    <span class="keyword">if</span> (canonicalName == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Local and anonymous classes can not be ViewModels"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建ViewModel中内存中的key</span></span><br><span class="line">    <span class="keyword">return</span> get(DEFAULT_KEY + <span class="string">":"</span> + canonicalName, modelClass);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@NonNull</span></span><br><span class="line">    <span class="meta">@MainThread</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T extends ViewModel&gt; <span class="function">T <span class="title">get</span><span class="params">(@NonNull String key, @NonNull Class&lt;T&gt; modelClass)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 从ViewModelStore中通过key获取ViewModel对象</span></span><br><span class="line">        ViewModel viewModel = mViewModelStore.get(key);</span><br><span class="line">		<span class="comment">// 通过key获取的对象与想要的Class相同直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (modelClass.isInstance(viewModel)) &#123;</span><br><span class="line">            <span class="keyword">return</span> (T) viewModel;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (viewModel != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// <span class="doctag">TODO:</span> log a warning.</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">// 通过ViewModelFactory创建ViewModel类，并通过key-value添加到store中</span></span><br><span class="line">        viewModel = mFactory.create(modelClass);</span><br><span class="line">        mViewModelStore.put(key, viewModel);</span><br><span class="line">        <span class="comment">//noinspection unchecked</span></span><br><span class="line">        <span class="keyword">return</span> (T) viewModel;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这里我们在上一步分析的两个关键类都起作用了:</p>
<ol>
<li><p>ViewModelStore:通过<strong>DEFAULT-KEY+类名</strong>存储ViewModel对象。</p>
</li>
<li><p>通过ViewModelFactory创建ViewModel对象。</p>
</li>
</ol>
<p><strong>ViewModelStore类：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ViewModelStore</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> HashMap&lt;String, ViewModel&gt; mMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(String key, ViewModel viewModel)</span> </span>&#123;</span><br><span class="line">        ViewModel oldViewModel = mMap.put(key, viewModel);</span><br><span class="line">        <span class="keyword">if</span> (oldViewModel != <span class="keyword">null</span>) &#123;</span><br><span class="line">            oldViewModel.onCleared();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">final</span> ViewModel <span class="title">get</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mMap.get(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  Clears internal storage and notifies ViewModels that they are no longer used.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (ViewModel vm : mMap.values()) &#123;</span><br><span class="line">            vm.onCleared();</span><br><span class="line">        &#125;</span><br><span class="line">        mMap.clear();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其就是一个HashMap的ViewModel容器，并且提供clear方法清空所有内容，既然要清空，那么肯定就在一个地方onDestroy()中做，所以看看FragmentActivity的onDestroy()，果然不出所料：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">protected void onDestroy() &#123;</span><br><span class="line">    super.onDestroy();</span><br><span class="line">    if (this.mViewModelStore != null &amp;&amp; !this.isChangingConfigurations()) &#123;</span><br><span class="line">      this.mViewModelStore.clear();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    this.mFragments.dispatchDestroy();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>这里还对要求 <strong>!this.isChangingConfigurations()</strong> ，就是如果因为系统configuration导致onDestroy这种情况不清楚ViewModel，这就是为什么横竖屏切换等场景Activity重建了但是ViewModel依然健在。</p>
<h4 id="再捋一捋逻辑"><a href="#再捋一捋逻辑" class="headerlink" title="再捋一捋逻辑"></a>再捋一捋逻辑</h4><p>再看看这句代码：<code>model = ViewModelProviders.of(this).get(NameViewModel.class);</code></p>
<ol>
<li><p>首先第一步<strong>ViewModelProviders.of(this)</strong>获取ViewModelProvider对象，这个provider有两部分组成 ViewModelStore 和 AndroidViewModelFactory</p>
</li>
<li><p>获取ViewModelStore是通过ViewModelStoreOwner接口来的，每个组件自己去实现并创建自己的ViewModelStore，FragmentActivity，support.v4.app.Framgnet天然支持。如果传入的组件不支持，ViewModelStores 会创建一个隐藏的HolderFragment为你达到目的。</p>
</li>
<li>通过<strong>ViewModelProvider.get(xxx.class)</strong>会先到每个组件的ViewModelStore中去找，如果找不到通过AndroidViewModelFactory创建并放到ViewModelStore中。</li>
<li>当生命周期组件onDestroy的时候会清理ViewModelStore中的内容防止内存泄漏了，但是由于ConfigurationChange导致的onDestroy不会清理，因为会将ViewModel绑定到不因为configuration变化导致Activity销毁被清空的NonConfigurationInstances下，下一次重建依然会被获取到。</li>
</ol>
<h3 id="ViewModel的用法"><a href="#ViewModel的用法" class="headerlink" title="ViewModel的用法"></a>ViewModel的用法</h3><p>官网就给出了3大ViewModel的用途：</p>
<ol>
<li>结合LiveData，为View组件提供数据，并保证不因为Configuration变化导致数据丢失。</li>
<li>Fragment之间数据共享。<code>SharedViewModel model = ViewModelProviders.of(getActivity()).get(SharedViewModel.class);</code>同一个Activity下发不同Fragment可以通过传入Activity的context获取到相同的ViewModel对象。<strong>Why？同一个Activity获取同一个ViewModelStore，相同的.class获取到的就是相同的ViewModel。</strong></li>
<li>替换Loaders，至于这玩意儿是啥，我没用过。看图大概的意思就是：Loader从DataSource获取数据，通知给LoaderManager，LoaderManager通知UI Controller更新。使用ViewModel+LiveData天然就可以干这个事情。</li>
</ol>
]]></content>
      
        <categories>
            
            <category> Android源码解析系列 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Android Component </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Android事件分发机制详解]]></title>
      <url>/2018/08/25/Android%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3/</url>
      <content type="html"><![CDATA[<h2 id="什么是View事件分发"><a href="#什么是View事件分发" class="headerlink" title="什么是View事件分发"></a>什么是View事件分发</h2><p>这里的事件是指手指触屏到屏幕（Down）到手指离开屏幕（Up，Cancel）以及中间一系列（Move），这一连串的事件也叫事件序列。在Android开发中了解事件分发机制很重要，自定义View以及处理滑动冲突的时候都需要用到。</p>
<p>虽然事件分发时包含了从down到up过程的事件序列，但是这里更倾向去将事件分发定义为事件Down的分发，因为Down事件会决定后续所有事件的走向。下面我们从实际的例子中来看View的事件时怎么分发的。</p>
<p>先来一张简图：<br><img src="/2018/08/25/Android事件分发机制详解/WX20180825-170921.png" alt="WX20180825-170921"><br><a id="more"></a></p>
<h2 id="事件分发过程"><a href="#事件分发过程" class="headerlink" title="事件分发过程"></a>事件分发过程</h2><p>写一个层级大概如下的视图：</p>
<p><img src="/2018/08/25/Android事件分发机制详解/1.png" alt="1.png"></p>
<p>重写各个层级的Activity，ViewGroup，View的几个关键事件传递的方法。</p>
<ol>
<li>boolean dispatchTouchEvent(MotionEvent ev)</li>
<li>boolean onInterceptTouchEvent(MotionEvent ev)</li>
<li>boolean onTouchEvent(MotionEvent event)</li>
</ol>
<p>注意: </p>
<ol>
<li>这3个方法都用都有相同的输入和输出，输入为事件类型，输出为是否消费事件</li>
<li>Activity 和 View 没有onInterceptTouchEvent，只有ViewGroup才有。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class MainActivity extends AppCompatActivity &#123;</span><br><span class="line">    // ...</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean dispatchTouchEvent(MotionEvent ev) &#123;</span><br><span class="line">        Log.e(TAG, &quot;dispatchTouchEvent: &quot; + ev.getAction());</span><br><span class="line">        return super.dispatchTouchEvent(ev);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean onTouchEvent(MotionEvent event) &#123;</span><br><span class="line">        Log.e(TAG, &quot;onTouchEvent: &quot; + event.getAction());</span><br><span class="line">        return super.onTouchEvent(event);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class FrameLayout1 extends FrameLayout &#123;</span><br><span class="line">    // ...</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean dispatchTouchEvent(MotionEvent ev) &#123;</span><br><span class="line">        Log.i(TAG, &quot;dispatchTouchEvent: &quot; + ev.getAction());</span><br><span class="line">        return super.dispatchTouchEvent(ev);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean onInterceptTouchEvent(MotionEvent ev) &#123;</span><br><span class="line">        Log.i(TAG, &quot;onInterceptTouchEvent: &quot; + ev.getAction());</span><br><span class="line">        return super.dispatchTouchEvent(ev);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean onTouchEvent(MotionEvent ev) &#123;</span><br><span class="line">        Log.i(TAG, &quot;onTouchEvent: &quot; + ev.getAction());</span><br><span class="line">        return super.dispatchTouchEvent(ev);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>LinerLayout 同上FrameLayout ……</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class MyTextView extends android.support.v7.widget.AppCompatTextView &#123;</span><br><span class="line">    // ...</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean dispatchTouchEvent(MotionEvent event) &#123;</span><br><span class="line">        Log.d(TAG, &quot;dispatchTouchEvent: &quot; + event.getAction());</span><br><span class="line">        return super.dispatchTouchEvent(event);;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean onTouchEvent(MotionEvent event) &#123;</span><br><span class="line">        Log.d(TAG, &quot;onTouchEvent: &quot; + event.getAction());</span><br><span class="line">        return super.dispatchTouchEvent(event);;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-目前的代码没有拦截任何事件，都是直接调用-supper-xxx-传递事件-然后在屏幕上做一个滑动动作，拿到如下事件："><a href="#1-目前的代码没有拦截任何事件，都是直接调用-supper-xxx-传递事件-然后在屏幕上做一个滑动动作，拿到如下事件：" class="headerlink" title="1. 目前的代码没有拦截任何事件，都是直接调用 supper.xxx() 传递事件 然后在屏幕上做一个滑动动作，拿到如下事件："></a>1. <strong>目前的代码没有拦截任何事件，都是直接调用 supper.xxx() 传递事件</strong> 然后在屏幕上做一个滑动动作，拿到如下事件：</h3><p>PS: MotionEvent.getAction() 事件是 int 常量<br>0 -&gt; ACTION_DOWN<br>1 -&gt; ACTION_UP<br>2 -&gt; ACTION_MOVE<br>3 -&gt; ACTION_CANCEL<br>……</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">E/MainActivity: dispatchTouchEvent: 0</span><br><span class="line">I/FrameLayout1: dispatchTouchEvent: 0</span><br><span class="line">I/FrameLayout1: onInterceptTouchEvent: 0</span><br><span class="line">D/Linerlayout1: dispatchTouchEvent: 0</span><br><span class="line">D/Linerlayout1: onInterceptTouchEvent: 0</span><br><span class="line">D/MyTextView: dispatchTouchEvent: 0</span><br><span class="line">D/MyTextView: onTouchEvent: 0</span><br><span class="line">D/Linerlayout1: onTouchEvent: 0</span><br><span class="line">I/FrameLayout1: onTouchEvent: 0</span><br><span class="line">E/MainActivity: onTouchEvent: 0</span><br><span class="line">E/MainActivity: dispatchTouchEvent: 2</span><br><span class="line">E/MainActivity: onTouchEvent: 2</span><br><span class="line">E/MainActivity: dispatchTouchEvent: 2</span><br><span class="line">E/MainActivity: onTouchEvent: 2</span><br><span class="line">E/MainActivity: dispatchTouchEvent: 2</span><br><span class="line">E/MainActivity: onTouchEvent: 2</span><br><span class="line">E/MainActivity: dispatchTouchEvent: 1</span><br><span class="line">E/MainActivity: onTouchEvent: 1</span><br></pre></td></tr></table></figure>
<p>默认传递过程如下：<br>Down事件：从Activity的dispatch -&gt; Viewgroup的dispatch, intercept -&gt; View的 dispatch, ontouch -&gt; 父ViewGroup的 ontouch -&gt; Activity的 ontouch<br>Move事件：全部交给Activity<br>Up事件：  全部交给Activity</p>
<h3 id="2-在Framelayout的dispatchTouchEvent-中的-Down-事件中拦截返回-true，或-false"><a href="#2-在Framelayout的dispatchTouchEvent-中的-Down-事件中拦截返回-true，或-false" class="headerlink" title="2. 在Framelayout的dispatchTouchEvent 中的 Down 事件中拦截返回 true，或 false"></a>2. 在Framelayout的dispatchTouchEvent 中的 Down 事件中拦截返回 true，或 false</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public boolean dispatchTouchEvent(MotionEvent ev) &#123;</span><br><span class="line">    Log.i(TAG, &quot;dispatchTouchEvent: &quot; + ev.getAction());</span><br><span class="line">    switch (ev.getAction()) &#123;</span><br><span class="line">        case MotionEvent.ACTION_DOWN:</span><br><span class="line">            return true; // false</span><br><span class="line">        case MotionEvent.ACTION_MOVE:</span><br><span class="line">            break;</span><br><span class="line">        case MotionEvent.ACTION_UP:</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">    return super.dispatchTouchEvent(ev);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>返回true</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">E/MainActivity: dispatchTouchEvent: 0</span><br><span class="line">I/FrameLayout1: dispatchTouchEvent: 0</span><br><span class="line">E/MainActivity: dispatchTouchEvent: 2</span><br><span class="line">I/FrameLayout1: dispatchTouchEvent: 2</span><br><span class="line">I/FrameLayout1: onTouchEvent: 2</span><br><span class="line">E/MainActivity: onTouchEvent: 2</span><br><span class="line">E/MainActivity: dispatchTouchEvent: 2</span><br><span class="line">I/FrameLayout1: dispatchTouchEvent: 2</span><br><span class="line">I/FrameLayout1: onTouchEvent: 2</span><br><span class="line">E/MainActivity: onTouchEvent: 2</span><br><span class="line">E/MainActivity: dispatchTouchEvent: 1</span><br><span class="line">I/FrameLayout1: dispatchTouchEvent: 1</span><br><span class="line">I/FrameLayout1: onTouchEvent: 1</span><br><span class="line">E/MainActivity: onTouchEvent: 1</span><br></pre></td></tr></table></figure></p>
<p><strong>返回false</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">E/MainActivity: dispatchTouchEvent: 0</span><br><span class="line">I/FrameLayout1: dispatchTouchEvent: 0</span><br><span class="line">E/MainActivity: onTouchEvent: 0</span><br><span class="line">E/MainActivity: dispatchTouchEvent: 2</span><br><span class="line">E/MainActivity: onTouchEvent: 2</span><br><span class="line">E/MainActivity: dispatchTouchEvent: 2</span><br><span class="line">E/MainActivity: onTouchEvent: 2</span><br><span class="line">E/MainActivity: dispatchTouchEvent: 1</span><br><span class="line">E/MainActivity: onTouchEvent: 1</span><br></pre></td></tr></table></figure></p>
<p>得出结论：<br>如果在dispatch中并且事件是down，返回true和false都会导致事件不向子View传递（因为没有调用super.dispatchXXX())，返回true和false的区别在于：</p>
<ol>
<li>返回true表示此view消耗了事件，下一次move事件依然会传递到这里，并且直接传递给onTouchEvent（不在调用onIntercept）</li>
<li>如果返回false，由于Framelayout上一层就是Activity，所以之后的事件都不会再传递下来。</li>
</ol>
<h3 id="3-在Framelayout的onIntercept中且事件未Down时返回true或false"><a href="#3-在Framelayout的onIntercept中且事件未Down时返回true或false" class="headerlink" title="3. 在Framelayout的onIntercept中且事件未Down时返回true或false"></a>3. 在Framelayout的onIntercept中且事件未Down时返回true或false</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public boolean onInterceptTouchEvent(MotionEvent ev) &#123;</span><br><span class="line">    Log.i(TAG, &quot;onInterceptTouchEvent: &quot; + ev.getAction());</span><br><span class="line">    switch (ev.getAction()) &#123;</span><br><span class="line">        case MotionEvent.ACTION_DOWN:</span><br><span class="line">            return true; // false</span><br><span class="line">        case MotionEvent.ACTION_MOVE:</span><br><span class="line">            break;</span><br><span class="line">        case MotionEvent.ACTION_UP:</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">    return super.onInterceptTouchEvent(ev);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>返回true</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">E/MainActivity: dispatchTouchEvent: 0</span><br><span class="line">I/FrameLayout1: dispatchTouchEvent: 0</span><br><span class="line">I/FrameLayout1: onInterceptTouchEvent: 0</span><br><span class="line">I/FrameLayout1: onTouchEvent: 0</span><br><span class="line">E/MainActivity: onTouchEvent: 0</span><br><span class="line">E/MainActivity: dispatchTouchEvent: 2</span><br><span class="line">E/MainActivity: onTouchEvent: 2</span><br><span class="line">E/MainActivity: dispatchTouchEvent: 2</span><br><span class="line">E/MainActivity: onTouchEvent: 2</span><br></pre></td></tr></table></figure></p>
<p><strong>返回false</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">E/MainActivity: dispatchTouchEvent: 0</span><br><span class="line">I/FrameLayout1: dispatchTouchEvent: 0</span><br><span class="line">I/FrameLayout1: onInterceptTouchEvent: 0</span><br><span class="line">D/Linerlayout1: dispatchTouchEvent: 0</span><br><span class="line">D/Linerlayout1: onInterceptTouchEvent: 0</span><br><span class="line">D/Linerlayout1: onTouchEvent: 0</span><br><span class="line">I/FrameLayout1: onTouchEvent: 0</span><br><span class="line">E/MainActivity: onTouchEvent: 0</span><br><span class="line">E/MainActivity: dispatchTouchEvent: 2</span><br><span class="line">E/MainActivity: onTouchEvent: 2</span><br><span class="line">E/MainActivity: dispatchTouchEvent: 2</span><br><span class="line">E/MainActivity: onTouchEvent: 2</span><br></pre></td></tr></table></figure></p>
<p>当事件为Down时，如果onInterceptTouchEvent() </p>
<ol>
<li>返回true，表示拦截，直接调用自己的onTouchEvent，事件不再向下传递</li>
<li>返回false，不拦截（默认），继续传递事件到子view，流程和调用super.onInterceptXXX一样</li>
</ol>
<h3 id="4-在LinearLayout的onTouchEvent中返回true或false"><a href="#4-在LinearLayout的onTouchEvent中返回true或false" class="headerlink" title="4. 在LinearLayout的onTouchEvent中返回true或false"></a>4. 在LinearLayout的onTouchEvent中返回true或false</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public boolean onTouchEvent(MotionEvent ev) &#123;</span><br><span class="line">    Log.i(TAG, &quot;onTouchEvent: &quot; + ev.getAction());</span><br><span class="line">    switch (ev.getAction()) &#123;</span><br><span class="line">        case MotionEvent.ACTION_DOWN:</span><br><span class="line">            return true; // false</span><br><span class="line">        case MotionEvent.ACTION_MOVE:</span><br><span class="line">            break;</span><br><span class="line">        case MotionEvent.ACTION_UP:</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">    return super.onInterceptTouchEvent(ev);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>返回true：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">E/MainActivity: dispatchTouchEvent: 0</span><br><span class="line">I/FrameLayout1: dispatchTouchEvent: 0</span><br><span class="line">I/FrameLayout1: onInterceptTouchEvent: 0</span><br><span class="line">D/Linerlayout1: dispatchTouchEvent: 0</span><br><span class="line">D/Linerlayout1: onInterceptTouchEvent: 0</span><br><span class="line">D/MyTextView: dispatchTouchEvent: 0</span><br><span class="line">D/MyTextView: onTouchEvent: 0</span><br><span class="line">D/Linerlayout1: onTouchEvent: 0</span><br><span class="line">E/MainActivity: dispatchTouchEvent: 2</span><br><span class="line">I/FrameLayout1: dispatchTouchEvent: 2</span><br><span class="line">I/FrameLayout1: onInterceptTouchEvent: 2</span><br><span class="line">D/Linerlayout1: dispatchTouchEvent: 2</span><br><span class="line">--------------未调用自己的 onInterceptTouchEvent</span><br><span class="line">D/Linerlayout1: onTouchEvent: 2</span><br><span class="line">--------------未调用父View的 onTouchEvent</span><br><span class="line">E/MainActivity: onTouchEvent: 2</span><br><span class="line">E/MainActivity: dispatchTouchEvent: 1</span><br><span class="line">I/FrameLayout1: dispatchTouchEvent: 1</span><br><span class="line">I/FrameLayout1: onInterceptTouchEvent: 1</span><br><span class="line">D/Linerlayout1: dispatchTouchEvent: 1</span><br><span class="line">D/Linerlayout1: onTouchEvent: 1</span><br><span class="line">E/MainActivity: onTouchEvent: 1</span><br></pre></td></tr></table></figure>
<p><strong>返回false：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">E/MainActivity: dispatchTouchEvent: 0</span><br><span class="line">I/FrameLayout1: dispatchTouchEvent: 0</span><br><span class="line">I/FrameLayout1: onInterceptTouchEvent: 0</span><br><span class="line">D/Linerlayout1: dispatchTouchEvent: 0</span><br><span class="line">D/Linerlayout1: onInterceptTouchEvent: 0</span><br><span class="line">D/MyTextView: dispatchTouchEvent: 0</span><br><span class="line">D/MyTextView: onTouchEvent: 0</span><br><span class="line">D/Linerlayout1: onTouchEvent: 0</span><br><span class="line">I/FrameLayout1: onTouchEvent: 0</span><br><span class="line">E/MainActivity: onTouchEvent: 0</span><br><span class="line">E/MainActivity: dispatchTouchEvent: 2</span><br><span class="line">E/MainActivity: onTouchEvent: 2</span><br><span class="line">E/MainActivity: dispatchTouchEvent: 2</span><br><span class="line">E/MainActivity: onTouchEvent: 2</span><br><span class="line">E/MainActivity: dispatchTouchEvent: 1</span><br><span class="line">E/MainActivity: onTouchEvent: 1</span><br></pre></td></tr></table></figure>
<p>当事件为Down时，如果onTouchEvent：</p>
<p><strong>返回true：</strong>表示事件被此view消耗，之后所有move，cancel事件都会按照从上到下的路径传递到此view。但是需要注意，这个过程中<strong>自己的onIntercept没有被调用</strong>，并且<strong>自己的onTouchEvent之后直接调用Activity的onTouchevent，没有走Framelayout的onTouch</strong>。</p>
<p><strong>返回false：</strong>表示不消费事件，onTouch继续上传给父View，直到Activity，之后所有event都由Activity消费。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>对于事件Down来说非常重要，因为它决定了后续事件的流向。下图只是对于Down事件的一些case，还有很多case图上没有表现，可参考上面集中4种情况的log分析。</p>
<p><img src="/2018/08/25/Android事件分发机制详解/WX20180825-170921.png" alt="WX20180825-170921"></p>
<p>对于Down事件决定事件的流向可以这样理解，如果事件为Down时候，如果在dispatchTouchEvent 和 onTouchevent中只要返回true，那么该View会收到后续的所有事件。<strong>因为事件传递过程中记录了一个mFirstTouchTarget的对象，表示消费事件的view，如果确定了这个target那么事件会直接交给target处理。</strong></p>
<p>如果Down事件按照默认流程U型传递一圈发现没有消耗Down事件，那么后续事件也没有必要再向下传递，Activity直接消耗完即可。</p>
<p><strong>PS: 还有一个需要注意的地方，如果一个View的clickable或者longclickable的属性被设置为true，那么在它的onTouchEvent中会默认返回true。比如Button。这会导致默认情况它就会消耗事件</strong></p>
]]></content>
      
        <categories>
            
            <category> Android事件分发 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Android </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Gradle3.0多渠道打包详解]]></title>
      <url>/2017/12/31/Gradle3-0%E5%A4%9A%E6%B8%A0%E9%81%93%E6%89%93%E5%8C%85%E8%AF%A6%E8%A7%A3/</url>
      <content type="html"><![CDATA[<h2 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h2><p>Android开发中，经常我们需要打不同的包，常用的维度就是debug，release，多个渠道等，如果每个包都需要对应一份代码，那么工作量就巨大并且难以维护（修改代码需要修改多处）。Android中使用Gradle打包，可以很好的解决打包这个问题，提供了充分的可配置选项，让我们在很多维度控制打包的细节，非常灵活，推荐看官方文档（墙外）。</p>
<a id="more"></a>
<h2 id="productFlavor"><a href="#productFlavor" class="headerlink" title="productFlavor"></a>productFlavor</h2><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><p>productFlavor：产品风味。在多渠道打包是一般使用这个属性，可根据不同的渠道配置不同的内容。Gradle3.0之后配置flavor与之前略有不同，需要强制设置flavor的维度：flavorDimensions，否则gradle会报错，来个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">flavorDimensions(&apos;money&apos;)</span><br><span class="line">productFlavors &#123;</span><br><span class="line">    free &#123;</span><br><span class="line">        dimension &apos;money&apos;</span><br><span class="line">    &#125;</span><br><span class="line">    paid &#123;</span><br><span class="line">        dimension &apos;money&apos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例子中定义了一个产品风味维度：money（是否需要钱钱），然后定义了两种风味：free和paid，注意两种风味的<code>dimension</code>属性相同都是<code>money</code>。然后使用<code>./gradlew assemble</code>打包，如果你配置了你会发现app/build/outputs/apk 下会打出这些包：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">apk/</span><br><span class="line">	free/</span><br><span class="line">		debug/</span><br><span class="line">			xxx.apk</span><br><span class="line">		release/</span><br><span class="line">			xxx.apk</span><br><span class="line">	paid/</span><br><span class="line">		debug/</span><br><span class="line">			xxx.apk</span><br><span class="line">		release/</span><br><span class="line">			xxx.apk</span><br></pre></td></tr></table></figure>
<p>xxx.apk 命名规则是：<code>app-flavor-buildtype.apk</code></p>
<p><code>./gradlew assemble</code>很粗暴，会打出所有的包。如果你只想打一个包，比如：paid的release包，那么可以使用以下命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./gradlew assemblePaidRelease</span><br></pre></td></tr></table></figure>
<p>规则：<code>./gradlew assembleFlavorBuildtype</code>, buildtype（构建类型）指debug or release or 自己配置的buildtype。</p>
<h3 id="flavorDimensions"><a href="#flavorDimensions" class="headerlink" title="flavorDimensions"></a>flavorDimensions</h3><p>产品风味维度，打包时可以使用多个维度组合的方式。例如定义下面这种方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">flavorDimensions(&apos;money&apos;, &apos;channel&apos;)</span><br><span class="line">productFlavors &#123;</span><br><span class="line">    free &#123;</span><br><span class="line">        dimension &apos;money&apos;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    paid &#123;</span><br><span class="line">        dimension &apos;money&apos;</span><br><span class="line">    &#125;</span><br><span class="line">    baidu &#123;</span><br><span class="line">        dimension &apos;channel&apos;</span><br><span class="line">    &#125;</span><br><span class="line">    wandoujia &#123;</span><br><span class="line">        dimension &apos;channel&apos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后<code>./gradlew assemble</code>会打出 2x2=4个包，gralde会自动将两个维度的品味组合打包：free-baidu.apk, paid-baidu.apk, free-wandoujia.apk, paid-wandoujia.apk …</p>
<h3 id="配置依赖"><a href="#配置依赖" class="headerlink" title="配置依赖"></a>配置依赖</h3><p>关于不同的风味需要配置哪些属性，这里就不细讲，感兴趣自己查文档。我这里遇到一个需求是，不同的产品风味，需要依赖不同的lib。例如：我有两套log系统（一套会上传log，一套不会），分别写在两个lib中，主工程中定义了Log.java继承与两个lib中的BaseLog.java，BaseLog.java中控制log的细节。现在需要根据log这个风味维度打出两种不同log的包。大概配置如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">flavorDimensions(&apos;log&apos;)</span><br><span class="line">productFlavors &#123;</span><br><span class="line">    online &#123;</span><br><span class="line">        dimension &apos;log&apos;</span><br><span class="line">    &#125;</span><br><span class="line">    local &#123;</span><br><span class="line">        dimension &apos;log&apos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    ...</span><br><span class="line">    onlineImplementation project(&apos;:libs:lib-log-online&apos;)</span><br><span class="line">    localImplementation project(&apos;:libs:lib-log-local&apos;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主要看dependencies中两个配置：<code>onlineImplementation</code>，<code>localImplementation</code>分配表示online和local两种风味依赖两个本地不同的lib。gradle3.0之前是使用 <code>comple xxx</code>这里需要注意修改成<code>implementation</code>，命名规则依然是: <code>flavorImplementation</code>。</p>
<p>这样就可以实现根据不同的风味，控制不同的依赖。具体的配置还有很多内容，推荐看官方文档，这里不再累述。</p>
<h2 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h2><p><a href="https://developer.android.com/studio/build/build-variants.html" target="_blank" rel="noopener">https://developer.android.com/studio/build/build-variants.html</a></p>
<p><a href="https://developer.android.com/studio/build/index.html" target="_blank" rel="noopener">https://developer.android.com/studio/build/index.html</a></p>
]]></content>
      
        <categories>
            
            <category> Android打包 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Android </tag>
            
            <tag> Gradle </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Hexo命令清单]]></title>
      <url>/2017/12/18/Hexo%E5%91%BD%E4%BB%A4%E6%B8%85%E5%8D%95/</url>
      <content type="html"><![CDATA[<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><p>创建文章, layout可使用 post(默认), draft(草稿), page …</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new [layout] &quot;Article Name&quot;</span><br></pre></td></tr></table></figure>
<p>发布草稿</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo publish [layout] &lt;title&gt;</span><br></pre></td></tr></table></figure>
<p>生成静态文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br><span class="line">$ hexo g</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>发布更新</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br><span class="line">$ hexo d</span><br></pre></td></tr></table></figure>
<p>生成并发布</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo d -g</span><br></pre></td></tr></table></figure>
<p>启动本地server查看, 默认： localhost:4000, 可自行指定参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br><span class="line">$ hexo s</span><br></pre></td></tr></table></figure>
<p>生成并预览</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo s -g</span><br></pre></td></tr></table></figure>
<h2 id="官方地址"><a href="#官方地址" class="headerlink" title="官方地址"></a>官方地址</h2><p><a href="https://hexo.io" target="_blank" rel="noopener">https://hexo.io</a></p>
<p><a href="https://hexo.io/docs/" target="_blank" rel="noopener">https://hexo.io/docs/</a></p>
<p><a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">https://hexo.io/docs/troubleshooting.html</a></p>
<p><a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">https://github.com/hexojs/hexo/issues</a></p>
]]></content>
      
        <categories>
            
            <category> Hexo </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
