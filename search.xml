<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[ViewModel源码解读]]></title>
      <url>/2019/03/24/ViewModel%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/</url>
      <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>本片文章主要解读Android官方推荐组件ViewModel的底层实现原理，ViewModel作为Activity/Fragment等组件的数据容器，可以避免我们在View层自己创建并保存数据，都交给ViewModel管理，在横竖屏切换等场景也能很好适配。让我们再不需要再onSaveInstanceState()来保存临时变量，并且ViewModel可能很好的适应组件的生命周期，在Activity等组件onDestroy()时自动清除数据避免内存泄漏。</p>
<a id="more"></a>
<h2 id="源码解读"><a href="#源码解读" class="headerlink" title="源码解读"></a>源码解读</h2><h3 id="使用方法（官网例子）"><a href="#使用方法（官网例子）" class="headerlink" title="使用方法（官网例子）"></a>使用方法（官网例子）</h3><p>第1步：声明ViewModel组件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyViewModel</span> <span class="keyword">extends</span> <span class="title">ViewModel</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> MutableLiveData&lt;List&lt;User&gt;&gt; users;</span><br><span class="line">    <span class="keyword">public</span> LiveData&lt;List&lt;User&gt;&gt; getUsers() &#123;</span><br><span class="line">        <span class="keyword">if</span> (users == <span class="keyword">null</span>) &#123;</span><br><span class="line">            users = <span class="keyword">new</span> MutableLiveData&lt;List&lt;User&gt;&gt;();</span><br><span class="line">            loadUsers();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> users;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">loadUsers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Do an asynchronous operation to fetch users.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第2步：在Activity中获取ViewModel组件，并获取ViewModel中存储的内容</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Create a ViewModel the first time the system calls an activity's onCreate() method.</span></span><br><span class="line">        <span class="comment">// Re-created activities receive the same MyViewModel instance created by the first activity.</span></span><br><span class="line"></span><br><span class="line">        MyViewModel model = ViewModelProviders.of(<span class="keyword">this</span>).get(MyViewModel.class);</span><br><span class="line">        model.getUsers().observe(<span class="keyword">this</span>, users -&gt; &#123;</span><br><span class="line">            <span class="comment">// update UI</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="内容解读"><a href="#内容解读" class="headerlink" title="内容解读"></a>内容解读</h3><p>首先需要注意：</p>
<ol>
<li>ViewModel这家伙不是我们直接new出来的，而是通过ViewModelProviders创建来的，所以其不受Activity等组件生命周期的限制。</li>
<li>如果对LiveData不了解，可以直接忽略，直接将它看成一个数据变量即可。</li>
</ol>
<h4 id="ViewModelProviders-的创建"><a href="#ViewModelProviders-的创建" class="headerlink" title="ViewModelProviders 的创建"></a>ViewModelProviders 的创建</h4><p>那么ViewModel是怎么通过ViewModelProviders创建的呢？首先看<code>ViewModelProviders.of(this)</code>，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ViewModelProvider <span class="title">of</span><span class="params">(@NonNull FragmentActivity activity,</span></span></span><br><span class="line"><span class="function"><span class="params">        @Nullable Factory factory)</span> </span>&#123;</span><br><span class="line">    Application application = checkApplication(activity);</span><br><span class="line">    <span class="keyword">if</span> (factory == <span class="keyword">null</span>) &#123;</span><br><span class="line">        factory = ViewModelProvider.AndroidViewModelFactory.getInstance(application);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ViewModelProvider(ViewModelStores.of(activity), factory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建了一个<strong>ViewModelProvider</strong>对象，有两个参数：</p>
<ol>
<li><strong>ViewModelStores.of(activity)</strong> 最后生成的是一个 <strong>ViewModelStore</strong> 对象</li>
<li><strong>ViewModelProvider.AndroidViewModelFactory.getInstance(application)</strong></li>
</ol>
<p>先看ViewModelStore的创建：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ViewModelStores</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ViewModelStores</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the &#123;<span class="doctag">@link</span> ViewModelStore&#125; of the given activity.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> activity an activity whose &#123;<span class="doctag">@code</span> ViewModelStore&#125; is requested</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> a &#123;<span class="doctag">@code</span> ViewModelStore&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="meta">@MainThread</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ViewModelStore <span class="title">of</span><span class="params">(@NonNull FragmentActivity activity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (activity <span class="keyword">instanceof</span> ViewModelStoreOwner) &#123;</span><br><span class="line">            <span class="keyword">return</span> ((ViewModelStoreOwner) activity).getViewModelStore();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> holderFragmentFor(activity).getViewModelStore();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the &#123;<span class="doctag">@link</span> ViewModelStore&#125; of the given fragment.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> fragment a fragment whose &#123;<span class="doctag">@code</span> ViewModelStore&#125; is requested</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> a &#123;<span class="doctag">@code</span> ViewModelStore&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="meta">@MainThread</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ViewModelStore <span class="title">of</span><span class="params">(@NonNull Fragment fragment)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (fragment <span class="keyword">instanceof</span> ViewModelStoreOwner) &#123;</span><br><span class="line">            <span class="keyword">return</span> ((ViewModelStoreOwner) fragment).getViewModelStore();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> holderFragmentFor(fragment).getViewModelStore();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过of方法，</p>
<ol>
<li>如果传入的Activity或Fragment实现了ViewModelStoreOwner接口，则直接返回getViewModelStore()返回的ViewModelStore</li>
<li>如果传入的组件不是ViewModelStoreOwner，需要获取HolderFragment的ViewModelStore。这是一种兼容方案。这里看一下Activity的方案，同理还有Fragment的，大同小异。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HolderFragment <span class="title">holderFragmentFor</span><span class="params">(FragmentActivity activity)</span> </span>&#123;</span><br><span class="line">    FragmentManager fm = activity.getSupportFragmentManager();</span><br><span class="line">    <span class="comment">// 通过tag从FragmentManager中找Fragment</span></span><br><span class="line">    HolderFragment holder = findHolderFragment(fm);</span><br><span class="line">    <span class="keyword">if</span> (holder != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> holder;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从创建了但是还没有commit的fragment缓存中读取，真正清除实在HolderFragment的onCreate执行后，即承载HolderFragment的容器onCreate()之后</span></span><br><span class="line">    holder = mNotCommittedActivityHolders.get(activity);</span><br><span class="line">    <span class="keyword">if</span> (holder != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> holder;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 注册生命周期回调，在onDestroy的时候清除 mNotCommittedActivityHolders中的对象。</span></span><br><span class="line">    <span class="keyword">if</span> (!mActivityCallbacksIsAdded) &#123;</span><br><span class="line">        mActivityCallbacksIsAdded = <span class="keyword">true</span>;</span><br><span class="line">        activity.getApplication().registerActivityLifecycleCallbacks(mActivityCallbacks);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建HolderFragment并add到FragmentManager中</span></span><br><span class="line">    holder = createHolderFragment(fm);</span><br><span class="line">    mNotCommittedActivityHolders.put(activity, holder);</span><br><span class="line">    <span class="keyword">return</span> holder;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到这里我们获取到了ViewModelOwner，然后通过getViewModelStore()获取到了ViewModelStore对象。ViewModelStoreOwner就是一个提供ViewModelStore的接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ViewModelStoreOwner</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns owned &#123;<span class="doctag">@link</span> ViewModelStore&#125;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> a &#123;<span class="doctag">@code</span> ViewModelStore&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="function">ViewModelStore <span class="title">getViewModelStore</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们来看FragmentActivity对这个接口的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">FragmentActivity extends SupportActivity implements ViewModelStoreOwner,...&#123;</span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> ViewModelStore <span class="title">getViewModelStore</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.getApplication() == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Your activity is not yet attached to the Application instance. You can't request ViewModel before onCreate call."</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.mViewModelStore == <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="comment">// 这里还跟configuration相关，真是考虑周到</span></span><br><span class="line">        FragmentActivity.NonConfigurationInstances nc = (FragmentActivity.NonConfigurationInstances)<span class="keyword">this</span>.getLastNonConfigurationInstance();</span><br><span class="line">        <span class="keyword">if</span> (nc != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">this</span>.mViewModelStore = nc.viewModelStore;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.mViewModelStore == <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">this</span>.mViewModelStore = <span class="keyword">new</span> ViewModelStore();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.mViewModelStore;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至此终于获取到ViewModelStore对象，是通过ViewModelStoreOwner接口来获取，需要Activity或者Fragment直接实现接口，如果不是先，系统会为我们的组件添加HolderFragment来做兼容。至于ViewModelStore有什么作用，到后面我们再看。现在看第二个参数 <strong>AndroidViewModelFactory</strong>的创建。这个factory类其实是ViewModelProvider的静态内部类，而且是个单例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AndroidViewModelFactory</span> <span class="keyword">extends</span> <span class="title">ViewModelProvider</span>.<span class="title">NewInstanceFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> AndroidViewModelFactory sInstance;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Retrieve a singleton instance of AndroidViewModelFactory.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> application an application to pass in &#123;<span class="doctag">@link</span> AndroidViewModel&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> A valid &#123;<span class="doctag">@link</span> AndroidViewModelFactory&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> AndroidViewModelFactory <span class="title">getInstance</span><span class="params">(@NonNull Application application)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (sInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            sInstance = <span class="keyword">new</span> AndroidViewModelFactory(application);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sInstance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Application mApplication;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a &#123;<span class="doctag">@code</span> AndroidViewModelFactory&#125;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> application an application to pass in &#123;<span class="doctag">@link</span> AndroidViewModel&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AndroidViewModelFactory</span><span class="params">(@NonNull Application application)</span> </span>&#123;</span><br><span class="line">        mApplication = application;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T extends ViewModel&gt; <span class="function">T <span class="title">create</span><span class="params">(@NonNull Class&lt;T&gt; modelClass)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (AndroidViewModel.class.isAssignableFrom(modelClass)) &#123;</span><br><span class="line">            <span class="comment">//noinspection TryWithIdenticalCatches</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> modelClass.getConstructor(Application.class).newInstance(mApplication);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Cannot create an instance of "</span> + modelClass, e);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Cannot create an instance of "</span> + modelClass, e);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InstantiationException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Cannot create an instance of "</span> + modelClass, e);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Cannot create an instance of "</span> + modelClass, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.create(modelClass);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>唯一一个重要方法就是 create方法，通过反射直接创建ViewModel对象。</p>
<h4 id="ViewModelProvider的功能"><a href="#ViewModelProvider的功能" class="headerlink" title="ViewModelProvider的功能"></a>ViewModelProvider的功能</h4><p>刚刚我们分析了通过<code>ViewModelProviders.of(this)</code>创建了一个ViewModelProvider对象，然后我们再看Activity中的代码 <code>model = ViewModelProviders.of(this).get(NameViewModel.class);</code>下一步就是通过 ViewModelProvider的get(Class)方法来获取ViewModel对象：</p>
<p>ViewModelProvider类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@NonNull</span></span><br><span class="line"><span class="meta">@MainThread</span></span><br><span class="line"><span class="keyword">public</span> &lt;T extends ViewModel&gt; <span class="function">T <span class="title">get</span><span class="params">(@NonNull Class&lt;T&gt; modelClass)</span> </span>&#123;</span><br><span class="line">    String canonicalName = modelClass.getCanonicalName();</span><br><span class="line">    <span class="keyword">if</span> (canonicalName == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Local and anonymous classes can not be ViewModels"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建ViewModel中内存中的key</span></span><br><span class="line">    <span class="keyword">return</span> get(DEFAULT_KEY + <span class="string">":"</span> + canonicalName, modelClass);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@NonNull</span></span><br><span class="line">    <span class="meta">@MainThread</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T extends ViewModel&gt; <span class="function">T <span class="title">get</span><span class="params">(@NonNull String key, @NonNull Class&lt;T&gt; modelClass)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 从ViewModelStore中通过key获取ViewModel对象</span></span><br><span class="line">        ViewModel viewModel = mViewModelStore.get(key);</span><br><span class="line">		<span class="comment">// 通过key获取的对象与想要的Class相同直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (modelClass.isInstance(viewModel)) &#123;</span><br><span class="line">            <span class="keyword">return</span> (T) viewModel;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (viewModel != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// <span class="doctag">TODO:</span> log a warning.</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">// 通过ViewModelFactory创建ViewModel类，并通过key-value添加到store中</span></span><br><span class="line">        viewModel = mFactory.create(modelClass);</span><br><span class="line">        mViewModelStore.put(key, viewModel);</span><br><span class="line">        <span class="comment">//noinspection unchecked</span></span><br><span class="line">        <span class="keyword">return</span> (T) viewModel;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这里我们在上一步分析的两个关键类都起作用了:</p>
<ol>
<li><p>ViewModelStore:通过<strong>DEFAULT-KEY+类名</strong>存储ViewModel对象。</p>
</li>
<li><p>通过ViewModelFactory创建ViewModel对象。</p>
</li>
</ol>
<p><strong>ViewModelStore类：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ViewModelStore</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> HashMap&lt;String, ViewModel&gt; mMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(String key, ViewModel viewModel)</span> </span>&#123;</span><br><span class="line">        ViewModel oldViewModel = mMap.put(key, viewModel);</span><br><span class="line">        <span class="keyword">if</span> (oldViewModel != <span class="keyword">null</span>) &#123;</span><br><span class="line">            oldViewModel.onCleared();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">final</span> ViewModel <span class="title">get</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mMap.get(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  Clears internal storage and notifies ViewModels that they are no longer used.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (ViewModel vm : mMap.values()) &#123;</span><br><span class="line">            vm.onCleared();</span><br><span class="line">        &#125;</span><br><span class="line">        mMap.clear();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其就是一个HashMap的ViewModel容器，并且提供clear方法清空所有内容，既然要清空，那么肯定就在一个地方onDestroy()中做，所以看看FragmentActivity的onDestroy()，果然不出所料：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">protected void onDestroy() &#123;</span><br><span class="line">    super.onDestroy();</span><br><span class="line">    if (this.mViewModelStore != null &amp;&amp; !this.isChangingConfigurations()) &#123;</span><br><span class="line">      this.mViewModelStore.clear();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    this.mFragments.dispatchDestroy();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>这里还对要求 <strong>!this.isChangingConfigurations()</strong> ，就是如果因为系统configuration导致onDestroy这种情况不清楚ViewModel，这就是为什么横竖屏切换等场景Activity重建了但是ViewModel依然健在。</p>
<h4 id="再捋一捋逻辑"><a href="#再捋一捋逻辑" class="headerlink" title="再捋一捋逻辑"></a>再捋一捋逻辑</h4><p>再看看这句代码：<code>model = ViewModelProviders.of(this).get(NameViewModel.class);</code></p>
<ol>
<li><p>首先第一步<strong>ViewModelProviders.of(this)</strong>获取ViewModelProvider对象，这个provider有两部分组成 ViewModelStore 和 AndroidViewModelFactory</p>
</li>
<li><p>获取ViewModelStore是通过ViewModelStoreOwner接口来的，每个组件自己去实现并创建自己的ViewModelStore，FragmentActivity，support.v4.app.Framgnet天然支持。如果传入的组件不支持，ViewModelStores 会创建一个隐藏的HolderFragment为你达到目的。</p>
</li>
<li>通过<strong>ViewModelProvider.get(xxx.class)</strong>会先到每个组件的ViewModelStore中去找，如果找不到通过AndroidViewModelFactory创建并放到ViewModelStore中。</li>
<li>当生命周期组件onDestroy的时候会清理ViewModelStore中的内容防止内存泄漏了，但是由于ConfigurationChange导致的onDestroy不会清理，这就是ViewModel做的适配。</li>
</ol>
]]></content>
      
        <categories>
            
            <category> Android官方组件 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Android </tag>
            
            <tag> Android Component </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Android事件分发机制详解]]></title>
      <url>/2018/08/25/Android%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3/</url>
      <content type="html"><![CDATA[<h2 id="什么是View事件分发"><a href="#什么是View事件分发" class="headerlink" title="什么是View事件分发"></a>什么是View事件分发</h2><p>这里的事件是指手指触屏到屏幕（Down）到手指离开屏幕（Up，Cancel）以及中间一系列（Move），这一连串的事件也叫事件序列。在Android开发中了解事件分发机制很重要，自定义View以及处理滑动冲突的时候都需要用到。</p>
<p>虽然事件分发时包含了从down到up过程的事件序列，但是这里更倾向去将事件分发定义为事件Down的分发，因为Down事件会决定后续所有事件的走向。下面我们从实际的例子中来看View的事件时怎么分发的。</p>
<a id="more"></a>
<h2 id="事件分发过程"><a href="#事件分发过程" class="headerlink" title="事件分发过程"></a>事件分发过程</h2><p>写一个层级大概如下的视图：</p>
<p><img src="/2018/08/25/Android事件分发机制详解/1.png" alt="1.png"></p>
<p>重写各个层级的Activity，ViewGroup，View的几个关键事件传递的方法。</p>
<ol>
<li>boolean dispatchTouchEvent(MotionEvent ev)</li>
<li>boolean onInterceptTouchEvent(MotionEvent ev)</li>
<li>boolean onTouchEvent(MotionEvent event)</li>
</ol>
<p>注意: </p>
<ol>
<li>这3个方法都用都有相同的输入和输出，输入为事件类型，输出为是否消费事件</li>
<li>Activity 和 View 没有onInterceptTouchEvent，只有ViewGroup才有。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class MainActivity extends AppCompatActivity &#123;</span><br><span class="line">    // ...</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean dispatchTouchEvent(MotionEvent ev) &#123;</span><br><span class="line">        Log.e(TAG, &quot;dispatchTouchEvent: &quot; + ev.getAction());</span><br><span class="line">        return super.dispatchTouchEvent(ev);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean onTouchEvent(MotionEvent event) &#123;</span><br><span class="line">        Log.e(TAG, &quot;onTouchEvent: &quot; + event.getAction());</span><br><span class="line">        return super.onTouchEvent(event);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class FrameLayout1 extends FrameLayout &#123;</span><br><span class="line">    // ...</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean dispatchTouchEvent(MotionEvent ev) &#123;</span><br><span class="line">        Log.i(TAG, &quot;dispatchTouchEvent: &quot; + ev.getAction());</span><br><span class="line">        return super.dispatchTouchEvent(ev);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean onInterceptTouchEvent(MotionEvent ev) &#123;</span><br><span class="line">        Log.i(TAG, &quot;onInterceptTouchEvent: &quot; + ev.getAction());</span><br><span class="line">        return super.dispatchTouchEvent(ev);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean onTouchEvent(MotionEvent ev) &#123;</span><br><span class="line">        Log.i(TAG, &quot;onTouchEvent: &quot; + ev.getAction());</span><br><span class="line">        return super.dispatchTouchEvent(ev);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>LinerLayout 同上FrameLayout ……</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class MyTextView extends android.support.v7.widget.AppCompatTextView &#123;</span><br><span class="line">    // ...</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean dispatchTouchEvent(MotionEvent event) &#123;</span><br><span class="line">        Log.d(TAG, &quot;dispatchTouchEvent: &quot; + event.getAction());</span><br><span class="line">        return super.dispatchTouchEvent(event);;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean onTouchEvent(MotionEvent event) &#123;</span><br><span class="line">        Log.d(TAG, &quot;onTouchEvent: &quot; + event.getAction());</span><br><span class="line">        return super.dispatchTouchEvent(event);;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-目前的代码没有拦截任何事件，都是直接调用-supper-xxx-传递事件-然后在屏幕上做一个滑动动作，拿到如下事件："><a href="#1-目前的代码没有拦截任何事件，都是直接调用-supper-xxx-传递事件-然后在屏幕上做一个滑动动作，拿到如下事件：" class="headerlink" title="1. 目前的代码没有拦截任何事件，都是直接调用 supper.xxx() 传递事件 然后在屏幕上做一个滑动动作，拿到如下事件："></a>1. <strong>目前的代码没有拦截任何事件，都是直接调用 supper.xxx() 传递事件</strong> 然后在屏幕上做一个滑动动作，拿到如下事件：</h3><p>PS: MotionEvent.getAction() 事件是 int 常量<br>0 -&gt; ACTION_DOWN<br>1 -&gt; ACTION_UP<br>2 -&gt; ACTION_MOVE<br>3 -&gt; ACTION_CANCEL<br>……</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">E/MainActivity: dispatchTouchEvent: 0</span><br><span class="line">I/FrameLayout1: dispatchTouchEvent: 0</span><br><span class="line">I/FrameLayout1: onInterceptTouchEvent: 0</span><br><span class="line">D/Linerlayout1: dispatchTouchEvent: 0</span><br><span class="line">D/Linerlayout1: onInterceptTouchEvent: 0</span><br><span class="line">D/MyTextView: dispatchTouchEvent: 0</span><br><span class="line">D/MyTextView: onTouchEvent: 0</span><br><span class="line">D/Linerlayout1: onTouchEvent: 0</span><br><span class="line">I/FrameLayout1: onTouchEvent: 0</span><br><span class="line">E/MainActivity: onTouchEvent: 0</span><br><span class="line">E/MainActivity: dispatchTouchEvent: 2</span><br><span class="line">E/MainActivity: onTouchEvent: 2</span><br><span class="line">E/MainActivity: dispatchTouchEvent: 2</span><br><span class="line">E/MainActivity: onTouchEvent: 2</span><br><span class="line">E/MainActivity: dispatchTouchEvent: 2</span><br><span class="line">E/MainActivity: onTouchEvent: 2</span><br><span class="line">E/MainActivity: dispatchTouchEvent: 1</span><br><span class="line">E/MainActivity: onTouchEvent: 1</span><br></pre></td></tr></table></figure>
<p>默认传递过程如下：<br>Down事件：从Activity的dispatch -&gt; Viewgroup的dispatch, intercept -&gt; View的 dispatch, ontouch -&gt; 父ViewGroup的 ontouch -&gt; Activity的 ontouch<br>Move事件：全部交给Activity<br>Up事件：  全部交给Activity</p>
<h3 id="2-在Framelayout的dispatchTouchEvent-中的-Down-事件中拦截返回-true，或-false"><a href="#2-在Framelayout的dispatchTouchEvent-中的-Down-事件中拦截返回-true，或-false" class="headerlink" title="2. 在Framelayout的dispatchTouchEvent 中的 Down 事件中拦截返回 true，或 false"></a>2. 在Framelayout的dispatchTouchEvent 中的 Down 事件中拦截返回 true，或 false</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public boolean dispatchTouchEvent(MotionEvent ev) &#123;</span><br><span class="line">    Log.i(TAG, &quot;dispatchTouchEvent: &quot; + ev.getAction());</span><br><span class="line">    switch (ev.getAction()) &#123;</span><br><span class="line">        case MotionEvent.ACTION_DOWN:</span><br><span class="line">            return true; // false</span><br><span class="line">        case MotionEvent.ACTION_MOVE:</span><br><span class="line">            break;</span><br><span class="line">        case MotionEvent.ACTION_UP:</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">    return super.dispatchTouchEvent(ev);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>返回true</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">E/MainActivity: dispatchTouchEvent: 0</span><br><span class="line">I/FrameLayout1: dispatchTouchEvent: 0</span><br><span class="line">E/MainActivity: dispatchTouchEvent: 2</span><br><span class="line">I/FrameLayout1: dispatchTouchEvent: 2</span><br><span class="line">I/FrameLayout1: onTouchEvent: 2</span><br><span class="line">E/MainActivity: onTouchEvent: 2</span><br><span class="line">E/MainActivity: dispatchTouchEvent: 2</span><br><span class="line">I/FrameLayout1: dispatchTouchEvent: 2</span><br><span class="line">I/FrameLayout1: onTouchEvent: 2</span><br><span class="line">E/MainActivity: onTouchEvent: 2</span><br><span class="line">E/MainActivity: dispatchTouchEvent: 1</span><br><span class="line">I/FrameLayout1: dispatchTouchEvent: 1</span><br><span class="line">I/FrameLayout1: onTouchEvent: 1</span><br><span class="line">E/MainActivity: onTouchEvent: 1</span><br></pre></td></tr></table></figure></p>
<p><strong>返回false</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">E/MainActivity: dispatchTouchEvent: 0</span><br><span class="line">I/FrameLayout1: dispatchTouchEvent: 0</span><br><span class="line">E/MainActivity: onTouchEvent: 0</span><br><span class="line">E/MainActivity: dispatchTouchEvent: 2</span><br><span class="line">E/MainActivity: onTouchEvent: 2</span><br><span class="line">E/MainActivity: dispatchTouchEvent: 2</span><br><span class="line">E/MainActivity: onTouchEvent: 2</span><br><span class="line">E/MainActivity: dispatchTouchEvent: 1</span><br><span class="line">E/MainActivity: onTouchEvent: 1</span><br></pre></td></tr></table></figure></p>
<p>得出结论：<br>如果在dispatch中并且事件是down，返回true和false都会导致事件不向子View传递（因为没有调用super.dispatchXXX())，返回true和false的区别在于：</p>
<ol>
<li>返回true表示此view消耗了事件，下一次move事件依然会传递到这里，并且直接传递给onTouchEvent（不在调用onIntercept）</li>
<li>如果返回false，由于Framelayout上一层就是Activity，所以之后的事件都不会再传递下来。</li>
</ol>
<h3 id="3-在Framelayout的onIntercept中且事件未Down时返回true或false"><a href="#3-在Framelayout的onIntercept中且事件未Down时返回true或false" class="headerlink" title="3. 在Framelayout的onIntercept中且事件未Down时返回true或false"></a>3. 在Framelayout的onIntercept中且事件未Down时返回true或false</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public boolean onInterceptTouchEvent(MotionEvent ev) &#123;</span><br><span class="line">    Log.i(TAG, &quot;onInterceptTouchEvent: &quot; + ev.getAction());</span><br><span class="line">    switch (ev.getAction()) &#123;</span><br><span class="line">        case MotionEvent.ACTION_DOWN:</span><br><span class="line">            return true; // false</span><br><span class="line">        case MotionEvent.ACTION_MOVE:</span><br><span class="line">            break;</span><br><span class="line">        case MotionEvent.ACTION_UP:</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">    return super.onInterceptTouchEvent(ev);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>返回true</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">E/MainActivity: dispatchTouchEvent: 0</span><br><span class="line">I/FrameLayout1: dispatchTouchEvent: 0</span><br><span class="line">I/FrameLayout1: onInterceptTouchEvent: 0</span><br><span class="line">I/FrameLayout1: onTouchEvent: 0</span><br><span class="line">E/MainActivity: onTouchEvent: 0</span><br><span class="line">E/MainActivity: dispatchTouchEvent: 2</span><br><span class="line">E/MainActivity: onTouchEvent: 2</span><br><span class="line">E/MainActivity: dispatchTouchEvent: 2</span><br><span class="line">E/MainActivity: onTouchEvent: 2</span><br></pre></td></tr></table></figure></p>
<p><strong>返回false</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">E/MainActivity: dispatchTouchEvent: 0</span><br><span class="line">I/FrameLayout1: dispatchTouchEvent: 0</span><br><span class="line">I/FrameLayout1: onInterceptTouchEvent: 0</span><br><span class="line">D/Linerlayout1: dispatchTouchEvent: 0</span><br><span class="line">D/Linerlayout1: onInterceptTouchEvent: 0</span><br><span class="line">D/Linerlayout1: onTouchEvent: 0</span><br><span class="line">I/FrameLayout1: onTouchEvent: 0</span><br><span class="line">E/MainActivity: onTouchEvent: 0</span><br><span class="line">E/MainActivity: dispatchTouchEvent: 2</span><br><span class="line">E/MainActivity: onTouchEvent: 2</span><br><span class="line">E/MainActivity: dispatchTouchEvent: 2</span><br><span class="line">E/MainActivity: onTouchEvent: 2</span><br></pre></td></tr></table></figure></p>
<p>当事件为Down时，如果onInterceptTouchEvent() </p>
<ol>
<li>返回true，表示拦截，直接调用自己的onTouchEvent，事件不再向下传递</li>
<li>返回false，不拦截（默认），继续传递事件到子view，流程和调用super.onInterceptXXX一样</li>
</ol>
<h3 id="4-在LinearLayout的onTouchEvent中返回true或false"><a href="#4-在LinearLayout的onTouchEvent中返回true或false" class="headerlink" title="4. 在LinearLayout的onTouchEvent中返回true或false"></a>4. 在LinearLayout的onTouchEvent中返回true或false</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public boolean onTouchEvent(MotionEvent ev) &#123;</span><br><span class="line">    Log.i(TAG, &quot;onTouchEvent: &quot; + ev.getAction());</span><br><span class="line">    switch (ev.getAction()) &#123;</span><br><span class="line">        case MotionEvent.ACTION_DOWN:</span><br><span class="line">            return true; // false</span><br><span class="line">        case MotionEvent.ACTION_MOVE:</span><br><span class="line">            break;</span><br><span class="line">        case MotionEvent.ACTION_UP:</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">    return super.onInterceptTouchEvent(ev);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>返回true：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">E/MainActivity: dispatchTouchEvent: 0</span><br><span class="line">I/FrameLayout1: dispatchTouchEvent: 0</span><br><span class="line">I/FrameLayout1: onInterceptTouchEvent: 0</span><br><span class="line">D/Linerlayout1: dispatchTouchEvent: 0</span><br><span class="line">D/Linerlayout1: onInterceptTouchEvent: 0</span><br><span class="line">D/MyTextView: dispatchTouchEvent: 0</span><br><span class="line">D/MyTextView: onTouchEvent: 0</span><br><span class="line">D/Linerlayout1: onTouchEvent: 0</span><br><span class="line">E/MainActivity: dispatchTouchEvent: 2</span><br><span class="line">I/FrameLayout1: dispatchTouchEvent: 2</span><br><span class="line">I/FrameLayout1: onInterceptTouchEvent: 2</span><br><span class="line">D/Linerlayout1: dispatchTouchEvent: 2</span><br><span class="line">--------------未调用自己的 onInterceptTouchEvent</span><br><span class="line">D/Linerlayout1: onTouchEvent: 2</span><br><span class="line">--------------未调用父View的 onTouchEvent</span><br><span class="line">E/MainActivity: onTouchEvent: 2</span><br><span class="line">E/MainActivity: dispatchTouchEvent: 1</span><br><span class="line">I/FrameLayout1: dispatchTouchEvent: 1</span><br><span class="line">I/FrameLayout1: onInterceptTouchEvent: 1</span><br><span class="line">D/Linerlayout1: dispatchTouchEvent: 1</span><br><span class="line">D/Linerlayout1: onTouchEvent: 1</span><br><span class="line">E/MainActivity: onTouchEvent: 1</span><br></pre></td></tr></table></figure>
<p><strong>返回false：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">E/MainActivity: dispatchTouchEvent: 0</span><br><span class="line">I/FrameLayout1: dispatchTouchEvent: 0</span><br><span class="line">I/FrameLayout1: onInterceptTouchEvent: 0</span><br><span class="line">D/Linerlayout1: dispatchTouchEvent: 0</span><br><span class="line">D/Linerlayout1: onInterceptTouchEvent: 0</span><br><span class="line">D/MyTextView: dispatchTouchEvent: 0</span><br><span class="line">D/MyTextView: onTouchEvent: 0</span><br><span class="line">D/Linerlayout1: onTouchEvent: 0</span><br><span class="line">I/FrameLayout1: onTouchEvent: 0</span><br><span class="line">E/MainActivity: onTouchEvent: 0</span><br><span class="line">E/MainActivity: dispatchTouchEvent: 2</span><br><span class="line">E/MainActivity: onTouchEvent: 2</span><br><span class="line">E/MainActivity: dispatchTouchEvent: 2</span><br><span class="line">E/MainActivity: onTouchEvent: 2</span><br><span class="line">E/MainActivity: dispatchTouchEvent: 1</span><br><span class="line">E/MainActivity: onTouchEvent: 1</span><br></pre></td></tr></table></figure>
<p>当事件为Down时，如果onTouchEvent：</p>
<p><strong>返回true：</strong>表示事件被此view消耗，之后所有move，cancel事件都会按照从上到下的路径传递到此view。但是需要注意，这个过程中<strong>自己的onIntercept没有被调用</strong>，并且<strong>自己的onTouchEvent之后直接调用Activity的onTouchevent，没有走Framelayout的onTouch</strong>。</p>
<p><strong>返回false：</strong>表示不消费事件，onTouch继续上传给父View，直到Activity，之后所有event都由Activity消费。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>对于事件Down来说非常重要，因为它决定了后续事件的流向。下图只是对于Down事件的一些case，还有很多case图上没有表现，可参考上面集中4种情况的log分析。</p>
<p><img src="/2018/08/25/Android事件分发机制详解/WX20180825-170921.png" alt="WX20180825-170921"></p>
<p>对于Down事件决定事件的流向可以这样理解，如果事件为Down时候，如果在dispatchTouchEvent 和 onTouchevent中只要返回true，那么该View会收到后续的所有事件。<strong>因为事件传递过程中记录了一个mFirstTouchTarget的对象，表示消费事件的view，如果确定了这个target那么事件会直接交给target处理。</strong></p>
<p>如果Down事件按照默认流程U型传递一圈发现没有消耗Down事件，那么后续事件也没有必要再向下传递，Activity直接消耗完即可。</p>
<p><strong>PS: 还有一个需要注意的地方，如果一个View的clickable或者longclickable的属性被设置为true，那么在它的onTouchEvent中会默认返回true。比如Button。这会导致默认情况它就会消耗事件</strong></p>
]]></content>
      
        <categories>
            
            <category> Android </category>
            
            <category> 事件分发 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Android </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Gradle3.0多渠道打包详解]]></title>
      <url>/2017/12/31/Gradle3-0%E5%A4%9A%E6%B8%A0%E9%81%93%E6%89%93%E5%8C%85%E8%AF%A6%E8%A7%A3/</url>
      <content type="html"><![CDATA[<h2 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h2><p>Android开发中，经常我们需要打不同的包，常用的维度就是debug，release，多个渠道等，如果每个包都需要对应一份代码，那么工作量就巨大并且难以维护（修改代码需要修改多处）。Android中使用Gradle打包，可以很好的解决打包这个问题，提供了充分的可配置选项，让我们在很多维度控制打包的细节，非常灵活，推荐看官方文档（墙外）。</p>
<a id="more"></a>
<h2 id="productFlavor"><a href="#productFlavor" class="headerlink" title="productFlavor"></a>productFlavor</h2><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><p>productFlavor：产品风味。在多渠道打包是一般使用这个属性，可根据不同的渠道配置不同的内容。Gradle3.0之后配置flavor与之前略有不同，需要强制设置flavor的维度：flavorDimensions，否则gradle会报错，来个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">flavorDimensions(&apos;money&apos;)</span><br><span class="line">productFlavors &#123;</span><br><span class="line">    free &#123;</span><br><span class="line">        dimension &apos;money&apos;</span><br><span class="line">    &#125;</span><br><span class="line">    paid &#123;</span><br><span class="line">        dimension &apos;money&apos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例子中定义了一个产品风味维度：money（是否需要钱钱），然后定义了两种风味：free和paid，注意两种风味的<code>dimension</code>属性相同都是<code>money</code>。然后使用<code>./gradlew assemble</code>打包，如果你配置了你会发现app/build/outputs/apk 下会打出这些包：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">apk/</span><br><span class="line">	free/</span><br><span class="line">		debug/</span><br><span class="line">			xxx.apk</span><br><span class="line">		release/</span><br><span class="line">			xxx.apk</span><br><span class="line">	paid/</span><br><span class="line">		debug/</span><br><span class="line">			xxx.apk</span><br><span class="line">		release/</span><br><span class="line">			xxx.apk</span><br></pre></td></tr></table></figure>
<p>xxx.apk 命名规则是：<code>app-flavor-buildtype.apk</code></p>
<p><code>./gradlew assemble</code>很粗暴，会打出所有的包。如果你只想打一个包，比如：paid的release包，那么可以使用以下命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./gradlew assemblePaidRelease</span><br></pre></td></tr></table></figure>
<p>规则：<code>./gradlew assembleFlavorBuildtype</code>, buildtype（构建类型）指debug or release or 自己配置的buildtype。</p>
<h3 id="flavorDimensions"><a href="#flavorDimensions" class="headerlink" title="flavorDimensions"></a>flavorDimensions</h3><p>产品风味维度，打包时可以使用多个维度组合的方式。例如定义下面这种方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">flavorDimensions(&apos;money&apos;, &apos;channel&apos;)</span><br><span class="line">productFlavors &#123;</span><br><span class="line">    free &#123;</span><br><span class="line">        dimension &apos;money&apos;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    paid &#123;</span><br><span class="line">        dimension &apos;money&apos;</span><br><span class="line">    &#125;</span><br><span class="line">    baidu &#123;</span><br><span class="line">        dimension &apos;channel&apos;</span><br><span class="line">    &#125;</span><br><span class="line">    wandoujia &#123;</span><br><span class="line">        dimension &apos;channel&apos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后<code>./gradlew assemble</code>会打出 2x2=4个包，gralde会自动将两个维度的品味组合打包：free-baidu.apk, paid-baidu.apk, free-wandoujia.apk, paid-wandoujia.apk …</p>
<h3 id="配置依赖"><a href="#配置依赖" class="headerlink" title="配置依赖"></a>配置依赖</h3><p>关于不同的风味需要配置哪些属性，这里就不细讲，感兴趣自己查文档。我这里遇到一个需求是，不同的产品风味，需要依赖不同的lib。例如：我有两套log系统（一套会上传log，一套不会），分别写在两个lib中，主工程中定义了Log.java继承与两个lib中的BaseLog.java，BaseLog.java中控制log的细节。现在需要根据log这个风味维度打出两种不同log的包。大概配置如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">flavorDimensions(&apos;log&apos;)</span><br><span class="line">productFlavors &#123;</span><br><span class="line">    online &#123;</span><br><span class="line">        dimension &apos;log&apos;</span><br><span class="line">    &#125;</span><br><span class="line">    local &#123;</span><br><span class="line">        dimension &apos;log&apos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    ...</span><br><span class="line">    onlineImplementation project(&apos;:libs:lib-log-online&apos;)</span><br><span class="line">    localImplementation project(&apos;:libs:lib-log-local&apos;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主要看dependencies中两个配置：<code>onlineImplementation</code>，<code>localImplementation</code>分配表示online和local两种风味依赖两个本地不同的lib。gradle3.0之前是使用 <code>comple xxx</code>这里需要注意修改成<code>implementation</code>，命名规则依然是: <code>flavorImplementation</code>。</p>
<p>这样就可以实现根据不同的风味，控制不同的依赖。具体的配置还有很多内容，推荐看官方文档，这里不再累述。</p>
<h2 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h2><p><a href="https://developer.android.com/studio/build/build-variants.html" target="_blank" rel="noopener">https://developer.android.com/studio/build/build-variants.html</a></p>
<p><a href="https://developer.android.com/studio/build/index.html" target="_blank" rel="noopener">https://developer.android.com/studio/build/index.html</a></p>
]]></content>
      
        <categories>
            
            <category> Android </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Android </tag>
            
            <tag> 打包 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Hexo命令清单]]></title>
      <url>/2017/12/18/Hexo%E5%91%BD%E4%BB%A4%E6%B8%85%E5%8D%95/</url>
      <content type="html"><![CDATA[<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><p>创建文章, layout可使用 post(默认), draft(草稿), page …</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new [layout] &quot;Article Name&quot;</span><br></pre></td></tr></table></figure>
<p>发布草稿</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo publish [layout] &lt;title&gt;</span><br></pre></td></tr></table></figure>
<p>生成静态文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br><span class="line">$ hexo g</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>发布更新</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br><span class="line">$ hexo d</span><br></pre></td></tr></table></figure>
<p>生成并发布</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo d -g</span><br></pre></td></tr></table></figure>
<p>启动本地server查看, 默认： localhost:4000, 可自行指定参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br><span class="line">$ hexo s</span><br></pre></td></tr></table></figure>
<p>生成并预览</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo s -g</span><br></pre></td></tr></table></figure>
<h2 id="官方地址"><a href="#官方地址" class="headerlink" title="官方地址"></a>官方地址</h2><p><a href="https://hexo.io" target="_blank" rel="noopener">https://hexo.io</a></p>
<p><a href="https://hexo.io/docs/" target="_blank" rel="noopener">https://hexo.io/docs/</a></p>
<p><a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">https://hexo.io/docs/troubleshooting.html</a></p>
<p><a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">https://github.com/hexojs/hexo/issues</a></p>
]]></content>
      
        <categories>
            
            <category> Hexo </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
